{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC1822Proxiable} from \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport {ERC1967Utils} from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport {Initializable} from \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable __self = address(this);\n\n    /**\n     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`\n     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,\n     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.\n     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must\n     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function\n     * during an upgrade.\n     */\n    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";\n\n    /**\n     * @dev The call is from an unauthorized context.\n     */\n    error UUPSUnauthorizedCallContext();\n\n    /**\n     * @dev The storage `slot` is unsupported as a UUID.\n     */\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n\n    /**\n     * @dev Reverts if the execution is not performed via delegatecall or the execution\n     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.\n     * See {_onlyProxy}.\n     */\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || // Must be called through delegatecall\n            ERC1967Utils.getImplementation() != __self // Must be called through an active proxy\n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Reverts if the execution is performed via delegatecall.\n     * See {notDelegated}.\n     */\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            // Must not be called through delegatecall\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.\n     *\n     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value\n     * is expected to be the implementation slot in ERC1967.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            // The implementation is not UUPS\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\nimport {IERC5267} from \"@openzeppelin/contracts/interfaces/IERC5267.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n */\nabstract contract EIP712Upgradeable is Initializable, IERC5267 {\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.EIP712\n    struct EIP712Storage {\n        /// @custom:oz-renamed-from _HASHED_NAME\n        bytes32 _hashedName;\n        /// @custom:oz-renamed-from _HASHED_VERSION\n        bytes32 _hashedVersion;\n\n        string _name;\n        string _version;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.EIP712\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n\n        // Reset prior values in storage if upgrading\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        // If the hashed name and version in storage are non-zero, the contract hasn't been properly initialized\n        // and the EIP712 domain is not reliable, as it will be missing name and version.\n        require($._hashedName == 0 && $._hashedVersion == 0, \"EIP712: Uninitialized\");\n\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.\n     */\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            // If the name is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the name hash in storage if non-zero, otherwise we assume the name is empty by design.\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.\n     */\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            // If the version is empty, the contract may have been upgraded without initializing the new storage.\n            // We return the version hash in storage if non-zero, otherwise we assume the version is empty by design.\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256(\"\");\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.20;\n\nimport {Proxy} from \"../Proxy.sol\";\nimport {ERC1967Utils} from \"./ERC1967Utils.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an\n     * encoded function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     *\n     * Requirements:\n     *\n     * - If `data` is empty, `msg.value` must be zero.\n     */\n    constructor(address implementation, bytes memory _data) payable {\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Create2.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Not enough balance for performing a CREATE2 deploy.\n     */\n    error Create2InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev There's no code to deploy.\n     */\n    error Create2EmptyBytecode();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error Create2FailedDeployment();\n\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Create2InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        if (addr == address(0)) {\n            revert Create2FailedDeployment();\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/accounts/callback/TokenCallbackHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\n/* solhint-disable no-empty-blocks */\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\r\n\r\n/**\r\n * Token callback handler.\r\n *   Handles supported tokens' callbacks, allowing account receiving these tokens.\r\n */\r\nabstract contract TokenCallbackHandler is IERC721Receiver, IERC1155Receiver {\r\n\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) external pure override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721Receiver).interfaceId ||\r\n            interfaceId == type(IERC1155Receiver).interfaceId ||\r\n            interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n"
    },
    "contracts/accounts/SimpleAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable no-inline-assembly */\r\n/* solhint-disable reason-string */\r\n\r\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/EIP712Upgradeable.sol\";\r\nimport \"../core/BaseAccount.sol\";\r\nimport \"../core/Helpers.sol\";\r\nimport \"./callback/TokenCallbackHandler.sol\";\r\n\r\n/**\r\n * minimal account.\r\n *  this is sample minimal account.\r\n *  has execute, eth handling methods\r\n *  has a single signer that can send requests through the entryPoint.\r\n */\r\ncontract SimpleAccount is\r\n    BaseAccount,\r\n    Initializable,\r\n    TokenCallbackHandler,\r\n    EIP712Upgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    address public owner;\r\n\r\n    IEntryPoint private immutable _entryPoint;\r\n\r\n    event SimpleAccountInitialized(\r\n        IEntryPoint indexed entryPoint,\r\n        address indexed owner\r\n    );\r\n\r\n    modifier onlyOwner() {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc BaseAccount\r\n    function entryPoint() public view virtual override returns (IEntryPoint) {\r\n        return _entryPoint;\r\n    }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    receive() external payable {}\r\n\r\n    constructor(IEntryPoint anEntryPoint) {\r\n        _entryPoint = anEntryPoint;\r\n        _disableInitializers();\r\n    }\r\n\r\n    function _onlyOwner() internal view {\r\n        //directly from EOA owner, or through the account itself (which gets redirected through execute())\r\n        require(\r\n            msg.sender == owner || msg.sender == address(this),\r\n            \"only owner\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * execute a transaction (called directly from owner, or by entryPoint)\r\n     * @param dest destination address to call\r\n     * @param value the value to pass in this call\r\n     * @param func the calldata to pass in this call\r\n     */\r\n    function execute(\r\n        address dest,\r\n        uint256 value,\r\n        bytes calldata func\r\n    ) external {\r\n        _requireFromEntryPointOrOwner();\r\n        _call(dest, value, func);\r\n    }\r\n\r\n    /**\r\n     * execute a transaction (called directly from owner, or by entryPoint) authorized via signatures\r\n     \r\n     * @param to destination address to call\r\n     * @param value the value to pass in this call\r\n     * @param data the calldata to pass in this call\r\n     * @param validAfter unix timestamp after which the signature will be accepted\r\n     * @param validBefore unix timestamp until the signature will be accepted\r\n     * @param signature the signed type4 signature\r\n     */\r\n    function executeWithAuthorization(\r\n        address to,\r\n        uint256 value,\r\n        bytes calldata data,\r\n        uint256 validAfter,\r\n        uint256 validBefore,\r\n        bytes calldata signature\r\n    ) external payable {\r\n        require(block.timestamp > validAfter, \"Authorization not yet valid\");\r\n        require(block.timestamp < validBefore, \"Authorization expired\");\r\n\r\n        /**\r\n         * verify that the signature did sign the function call\r\n         */\r\n        bytes32 structHash = keccak256(\r\n            abi.encode(\r\n                keccak256(\r\n                    \"ExecuteWithAuthorization(address to,uint256 value,bytes data,uint256 validAfter,uint256 validBefore)\"\r\n                ),\r\n                to,\r\n                value,\r\n                keccak256(data),\r\n                validAfter,\r\n                validBefore\r\n            )\r\n        );\r\n        bytes32 digest = _hashTypedDataV4(structHash);\r\n\r\n        address recoveredAddress = ECDSA.recover(digest, signature);\r\n        require(recoveredAddress == owner, \"Invalid signer\");\r\n\r\n        // execute the instruction\r\n        _call(to, value, data);\r\n    }\r\n\r\n    /**\r\n     * execute a sequence of transactions\r\n     * @dev to reduce gas consumption for trivial case (no value), use a zero-length array to mean zero value\r\n     * @param dest an array of destination addresses\r\n     * @param value an array of values to pass to each call. can be zero-length for no-value calls\r\n     * @param func an array of calldata to pass to each call\r\n     */\r\n    function executeBatch(\r\n        address[] calldata dest,\r\n        uint256[] calldata value,\r\n        bytes[] calldata func\r\n    ) external {\r\n        _requireFromEntryPointOrOwner();\r\n        require(\r\n            dest.length == func.length &&\r\n                (value.length == 0 || value.length == func.length),\r\n            \"wrong array lengths\"\r\n        );\r\n        if (value.length == 0) {\r\n            for (uint256 i = 0; i < dest.length; i++) {\r\n                _call(dest[i], 0, func[i]);\r\n            }\r\n        } else {\r\n            for (uint256 i = 0; i < dest.length; i++) {\r\n                _call(dest[i], value[i], func[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev The _entryPoint member is immutable, to reduce gas consumption.  To upgrade EntryPoint,\r\n     * a new implementation of SimpleAccount must be deployed with the new EntryPoint address, then upgrading\r\n     * the implementation by calling `upgradeTo()`\r\n     * @param anOwner the owner (signer) of this account\r\n     */\r\n    function initialize(address anOwner) public virtual initializer {\r\n        _initialize(anOwner);\r\n        __EIP712_init(\"Wallet\", \"1\");\r\n        __UUPSUpgradeable_init();\r\n    }\r\n\r\n    function _initialize(address anOwner) internal virtual {\r\n        owner = anOwner;\r\n        emit SimpleAccountInitialized(_entryPoint, owner);\r\n    }\r\n\r\n    // Require the function call went through EntryPoint or owner\r\n    function _requireFromEntryPointOrOwner() internal view {\r\n        require(\r\n            msg.sender == address(entryPoint()) || msg.sender == owner,\r\n            \"account: not Owner or EntryPoint\"\r\n        );\r\n    }\r\n\r\n    /// implement template method of BaseAccount\r\n    function _validateSignature(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash\r\n    ) internal virtual override returns (uint256 validationData) {\r\n        bytes32 hash = MessageHashUtils.toEthSignedMessageHash(userOpHash);\r\n        if (owner != ECDSA.recover(hash, userOp.signature))\r\n            return SIG_VALIDATION_FAILED;\r\n        return SIG_VALIDATION_SUCCESS;\r\n    }\r\n\r\n    function _call(address target, uint256 value, bytes memory data) internal {\r\n        (bool success, bytes memory result) = target.call{value: value}(data);\r\n        if (!success) {\r\n            assembly {\r\n                revert(add(result, 32), mload(result))\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * check current account deposit in the entryPoint\r\n     */\r\n    function getDeposit() public view returns (uint256) {\r\n        return entryPoint().balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * deposit more funds for this account in the entryPoint\r\n     */\r\n    function addDeposit() public payable {\r\n        entryPoint().depositTo{value: msg.value}(address(this));\r\n    }\r\n\r\n    /**\r\n     * withdraw value from the account's deposit\r\n     * @param withdrawAddress target to send to\r\n     * @param amount to withdraw\r\n     */\r\n    function withdrawDepositTo(\r\n        address payable withdrawAddress,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        entryPoint().withdrawTo(withdrawAddress, amount);\r\n    }\r\n\r\n    function _authorizeUpgrade(\r\n        address newImplementation\r\n    ) internal view override {\r\n        (newImplementation);\r\n        _onlyOwner();\r\n    }\r\n}\r\n"
    },
    "contracts/accounts/SimpleAccountFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\r\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\r\n\r\nimport \"./SimpleAccount.sol\";\r\n\r\n/**\r\n * A sample factory contract for SimpleAccount\r\n * A UserOperations \"initCode\" holds the address of the factory, and a method call (to createAccount, in this sample factory).\r\n * The factory's createAccount returns the target account address even if it is already installed.\r\n * This way, the entryPoint.getSenderAddress() can be called either before or after the account is created.\r\n */\r\ncontract SimpleAccountFactory {\r\n    SimpleAccount public immutable accountImplementation;\r\n\r\n    constructor(IEntryPoint _entryPoint) {\r\n        accountImplementation = new SimpleAccount(_entryPoint);\r\n    }\r\n\r\n    /**\r\n     * create an account, and return its address.\r\n     * returns the address even if the account is already deployed.\r\n     * Note that during UserOperation execution, this method is called only if the account is not deployed.\r\n     * This method returns an existing account address so that entryPoint.getSenderAddress() would work even after account creation\r\n     */\r\n    function createAccount(address owner,uint256 salt) public returns (SimpleAccount ret) {\r\n        address addr = getAddress(owner, salt);\r\n        uint256 codeSize = addr.code.length;\r\n        if (codeSize > 0) {\r\n            return SimpleAccount(payable(addr));\r\n        }\r\n        ret = SimpleAccount(payable(new ERC1967Proxy{salt : bytes32(salt)}(\r\n                address(accountImplementation),\r\n                abi.encodeCall(SimpleAccount.initialize, (owner))\r\n            )));\r\n    }\r\n\r\n    /**\r\n     * calculate the counterfactual address of this account as it would be returned by createAccount()\r\n     */\r\n    function getAddress(address owner,uint256 salt) public view returns (address) {\r\n        return Create2.computeAddress(bytes32(salt), keccak256(abi.encodePacked(\r\n                type(ERC1967Proxy).creationCode,\r\n                abi.encode(\r\n                    address(accountImplementation),\r\n                    abi.encodeCall(SimpleAccount.initialize, (owner))\r\n                )\r\n            )));\r\n    }\r\n}\r\n"
    },
    "contracts/core/BaseAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable no-empty-blocks */\r\n\r\nimport \"../interfaces/IAccount.sol\";\r\nimport \"../interfaces/IEntryPoint.sol\";\r\nimport \"./UserOperationLib.sol\";\r\n\r\n/**\r\n * Basic account implementation.\r\n * This contract provides the basic logic for implementing the IAccount interface - validateUserOp\r\n * Specific account implementation should inherit it and provide the account-specific logic.\r\n */\r\nabstract contract BaseAccount is IAccount {\r\n    using UserOperationLib for PackedUserOperation;\r\n\r\n    /**\r\n     * Return the account nonce.\r\n     * This method returns the next sequential nonce.\r\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\r\n     */\r\n    function getNonce() public view virtual returns (uint256) {\r\n        return entryPoint().getNonce(address(this), 0);\r\n    }\r\n\r\n    /**\r\n     * Return the entryPoint used by this account.\r\n     * Subclass should return the current entryPoint used by this account.\r\n     */\r\n    function entryPoint() public view virtual returns (IEntryPoint);\r\n\r\n    /// @inheritdoc IAccount\r\n    function validateUserOp(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash,\r\n        uint256 missingAccountFunds\r\n    ) external virtual override returns (uint256 validationData) {\r\n        _requireFromEntryPoint();\r\n        validationData = _validateSignature(userOp, userOpHash);\r\n        _validateNonce(userOp.nonce);\r\n        _payPrefund(missingAccountFunds);\r\n    }\r\n\r\n    /**\r\n     * Ensure the request comes from the known entrypoint.\r\n     */\r\n    function _requireFromEntryPoint() internal view virtual {\r\n        require(\r\n            msg.sender == address(entryPoint()),\r\n            \"account: not from EntryPoint\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Validate the signature is valid for this message.\r\n     * @param userOp          - Validate the userOp.signature field.\r\n     * @param userOpHash      - Convenient field: the hash of the request, to check the signature against.\r\n     *                          (also hashes the entrypoint and chain id)\r\n     * @return validationData - Signature and time-range of this operation.\r\n     *                          <20-byte> aggregatorOrSigFail - 0 for valid signature, 1 to mark signature failure,\r\n     *                                    otherwise, an address of an aggregator contract.\r\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\r\n     *                          <6-byte> validAfter - first timestamp this operation is valid\r\n     *                          If the account doesn't use time-range, it is enough to return\r\n     *                          SIG_VALIDATION_FAILED value (1) for signature failure.\r\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\r\n     */\r\n    function _validateSignature(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash\r\n    ) internal virtual returns (uint256 validationData);\r\n\r\n    /**\r\n     * Validate the nonce of the UserOperation.\r\n     * This method may validate the nonce requirement of this account.\r\n     * e.g.\r\n     * To limit the nonce to use sequenced UserOps only (no \"out of order\" UserOps):\r\n     *      `require(nonce < type(uint64).max)`\r\n     * For a hypothetical account that *requires* the nonce to be out-of-order:\r\n     *      `require(nonce & type(uint64).max == 0)`\r\n     *\r\n     * The actual nonce uniqueness is managed by the EntryPoint, and thus no other\r\n     * action is needed by the account itself.\r\n     *\r\n     * @param nonce to validate\r\n     *\r\n     * solhint-disable-next-line no-empty-blocks\r\n     */\r\n    function _validateNonce(uint256 nonce) internal view virtual {\r\n    }\r\n\r\n    /**\r\n     * Sends to the entrypoint (msg.sender) the missing funds for this transaction.\r\n     * SubClass MAY override this method for better funds management\r\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\r\n     * it will not be required to send again).\r\n     * @param missingAccountFunds - The minimum value this method should send the entrypoint.\r\n     *                              This value MAY be zero, in case there is enough deposit,\r\n     *                              or the userOp has a paymaster.\r\n     */\r\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\r\n        if (missingAccountFunds != 0) {\r\n            (bool success, ) = payable(msg.sender).call{\r\n                value: missingAccountFunds,\r\n                gas: type(uint256).max\r\n            }(\"\");\r\n            (success);\r\n            //ignore failure (its EntryPoint's job to verify, not account.)\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/BasePaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\n/* solhint-disable reason-string */\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\nimport \"../interfaces/IPaymaster.sol\";\r\nimport \"../interfaces/IEntryPoint.sol\";\r\nimport \"./UserOperationLib.sol\";\r\n/**\r\n * Helper class for creating a paymaster.\r\n * provides helper methods for staking.\r\n * Validates that the postOp is called only by the entryPoint.\r\n */\r\nabstract contract BasePaymaster is IPaymaster, Ownable {\r\n    IEntryPoint public immutable entryPoint;\r\n\r\n    uint256 internal constant PAYMASTER_VALIDATION_GAS_OFFSET = UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET;\r\n    uint256 internal constant PAYMASTER_POSTOP_GAS_OFFSET = UserOperationLib.PAYMASTER_POSTOP_GAS_OFFSET;\r\n    uint256 internal constant PAYMASTER_DATA_OFFSET = UserOperationLib.PAYMASTER_DATA_OFFSET;\r\n\r\n    constructor(IEntryPoint _entryPoint) Ownable(msg.sender) {\r\n        _validateEntryPointInterface(_entryPoint);\r\n        entryPoint = _entryPoint;\r\n    }\r\n\r\n    //sanity check: make sure this EntryPoint was compiled against the same\r\n    // IEntryPoint of this paymaster\r\n    function _validateEntryPointInterface(IEntryPoint _entryPoint) internal virtual {\r\n        require(IERC165(address(_entryPoint)).supportsInterface(type(IEntryPoint).interfaceId), \"IEntryPoint interface mismatch\");\r\n    }\r\n\r\n    /// @inheritdoc IPaymaster\r\n    function validatePaymasterUserOp(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash,\r\n        uint256 maxCost\r\n    ) external override returns (bytes memory context, uint256 validationData) {\r\n        _requireFromEntryPoint();\r\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\r\n    }\r\n\r\n    /**\r\n     * Validate a user operation.\r\n     * @param userOp     - The user operation.\r\n     * @param userOpHash - The hash of the user operation.\r\n     * @param maxCost    - The maximum cost of the user operation.\r\n     */\r\n    function _validatePaymasterUserOp(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash,\r\n        uint256 maxCost\r\n    ) internal virtual returns (bytes memory context, uint256 validationData);\r\n\r\n    /// @inheritdoc IPaymaster\r\n    function postOp(\r\n        PostOpMode mode,\r\n        bytes calldata context,\r\n        uint256 actualGasCost,\r\n        uint256 actualUserOpFeePerGas\r\n    ) external override {\r\n        _requireFromEntryPoint();\r\n        _postOp(mode, context, actualGasCost, actualUserOpFeePerGas);\r\n    }\r\n\r\n    /**\r\n     * Post-operation handler.\r\n     * (verified to be called only through the entryPoint)\r\n     * @dev If subclass returns a non-empty context from validatePaymasterUserOp,\r\n     *      it must also implement this method.\r\n     * @param mode          - Enum with the following options:\r\n     *                        opSucceeded - User operation succeeded.\r\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\r\n     *                        postOpReverted - never passed in a call to postOp().\r\n     * @param context       - The context value returned by validatePaymasterUserOp\r\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\r\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\r\n     *                        and maxPriorityFee (and basefee)\r\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\r\n     */\r\n    function _postOp(\r\n        PostOpMode mode,\r\n        bytes calldata context,\r\n        uint256 actualGasCost,\r\n        uint256 actualUserOpFeePerGas\r\n    ) internal virtual {\r\n        (mode, context, actualGasCost, actualUserOpFeePerGas); // unused params\r\n        // subclass must override this method if validatePaymasterUserOp returns a context\r\n        revert(\"must override\");\r\n    }\r\n\r\n    /**\r\n     * Add a deposit for this paymaster, used for paying for transaction fees.\r\n     */\r\n    function deposit() public payable {\r\n        entryPoint.depositTo{value: msg.value}(address(this));\r\n    }\r\n\r\n    /**\r\n     * Withdraw value from the deposit.\r\n     * @param withdrawAddress - Target to send to.\r\n     * @param amount          - Amount to withdraw.\r\n     */\r\n    function withdrawTo(\r\n        address payable withdrawAddress,\r\n        uint256 amount\r\n    ) public onlyOwner {\r\n        entryPoint.withdrawTo(withdrawAddress, amount);\r\n    }\r\n\r\n    /**\r\n     * Add stake for this paymaster.\r\n     * This method can also carry eth value to add to the current stake.\r\n     * @param unstakeDelaySec - The unstake delay for this paymaster. Can only be increased.\r\n     */\r\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\r\n        entryPoint.addStake{value: msg.value}(unstakeDelaySec);\r\n    }\r\n\r\n    /**\r\n     * Return current paymaster's deposit on the entryPoint.\r\n     */\r\n    function getDeposit() public view returns (uint256) {\r\n        return entryPoint.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * Unlock the stake, in order to withdraw it.\r\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\r\n     */\r\n    function unlockStake() external onlyOwner {\r\n        entryPoint.unlockStake();\r\n    }\r\n\r\n    /**\r\n     * Withdraw the entire paymaster's stake.\r\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\r\n     * @param withdrawAddress - The address to send withdrawn value.\r\n     */\r\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\r\n        entryPoint.withdrawStake(withdrawAddress);\r\n    }\r\n\r\n    /**\r\n     * Validate the call is made from a valid entrypoint\r\n     */\r\n    function _requireFromEntryPoint() internal virtual {\r\n        require(msg.sender == address(entryPoint), \"Sender not EntryPoint\");\r\n    }\r\n}\r\n"
    },
    "contracts/core/EntryPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable no-inline-assembly */\r\n\r\nimport \"../interfaces/IAccount.sol\";\r\nimport \"../interfaces/IAccountExecute.sol\";\r\nimport \"../interfaces/IPaymaster.sol\";\r\nimport \"../interfaces/IEntryPoint.sol\";\r\n\r\nimport \"../utils/Exec.sol\";\r\nimport \"./StakeManager.sol\";\r\nimport \"./SenderCreator.sol\";\r\nimport \"./Helpers.sol\";\r\nimport \"./NonceManager.sol\";\r\nimport \"./UserOperationLib.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n/*\r\n * Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\r\n * Only one instance required on each chain.\r\n */\r\n\r\n/// @custom:security-contact https://bounty.ethereum.org\r\ncontract EntryPoint is IEntryPoint, StakeManager, NonceManager, ReentrancyGuard, ERC165 {\r\n\r\n    using UserOperationLib for PackedUserOperation;\r\n\r\n    SenderCreator private immutable _senderCreator = new SenderCreator();\r\n\r\n    function senderCreator() internal view virtual returns (SenderCreator) {\r\n        return _senderCreator;\r\n    }\r\n\r\n    //compensate for innerHandleOps' emit message and deposit refund.\r\n    // allow some slack for future gas price changes.\r\n    uint256 private constant INNER_GAS_OVERHEAD = 10000;\r\n\r\n    // Marker for inner call revert on out of gas\r\n    bytes32 private constant INNER_OUT_OF_GAS = hex\"deaddead\";\r\n    bytes32 private constant INNER_REVERT_LOW_PREFUND = hex\"deadaa51\";\r\n\r\n    uint256 private constant REVERT_REASON_MAX_LEN = 2048;\r\n    uint256 private constant PENALTY_PERCENT = 10;\r\n\r\n    /// @inheritdoc IERC165\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        // note: solidity \"type(IEntryPoint).interfaceId\" is without inherited methods but we want to check everything\r\n        return interfaceId == (type(IEntryPoint).interfaceId ^ type(IStakeManager).interfaceId ^ type(INonceManager).interfaceId) ||\r\n            interfaceId == type(IEntryPoint).interfaceId ||\r\n            interfaceId == type(IStakeManager).interfaceId ||\r\n            interfaceId == type(INonceManager).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * Compensate the caller's beneficiary address with the collected fees of all UserOperations.\r\n     * @param beneficiary - The address to receive the fees.\r\n     * @param amount      - Amount to transfer.\r\n     */\r\n    function _compensate(address payable beneficiary, uint256 amount) internal {\r\n        require(beneficiary != address(0), \"AA90 invalid beneficiary\");\r\n        (bool success, ) = beneficiary.call{value: amount}(\"\");\r\n        require(success, \"AA91 failed send to beneficiary\");\r\n    }\r\n\r\n    /**\r\n     * Execute a user operation.\r\n     * @param opIndex    - Index into the opInfo array.\r\n     * @param userOp     - The userOp to execute.\r\n     * @param opInfo     - The opInfo filled by validatePrepayment for this userOp.\r\n     * @return collected - The total amount this userOp paid.\r\n     */\r\n    function _executeUserOp(\r\n        uint256 opIndex,\r\n        PackedUserOperation calldata userOp,\r\n        UserOpInfo memory opInfo\r\n    )\r\n    internal\r\n    returns\r\n    (uint256 collected) {\r\n        uint256 preGas = gasleft();\r\n        bytes memory context = getMemoryBytesFromOffset(opInfo.contextOffset);\r\n        bool success;\r\n        {\r\n            uint256 saveFreePtr;\r\n            assembly (\"memory-safe\") {\r\n                saveFreePtr := mload(0x40)\r\n            }\r\n            bytes calldata callData = userOp.callData;\r\n            bytes memory innerCall;\r\n            bytes4 methodSig;\r\n            assembly {\r\n                let len := callData.length\r\n                if gt(len, 3) {\r\n                    methodSig := calldataload(callData.offset)\r\n                }\r\n            }\r\n            if (methodSig == IAccountExecute.executeUserOp.selector) {\r\n                bytes memory executeUserOp = abi.encodeCall(IAccountExecute.executeUserOp, (userOp, opInfo.userOpHash));\r\n                innerCall = abi.encodeCall(this.innerHandleOp, (executeUserOp, opInfo, context));\r\n            } else\r\n            {\r\n                innerCall = abi.encodeCall(this.innerHandleOp, (callData, opInfo, context));\r\n            }\r\n            assembly (\"memory-safe\") {\r\n                success := call(gas(), address(), 0, add(innerCall, 0x20), mload(innerCall), 0, 32)\r\n                collected := mload(0)\r\n                mstore(0x40, saveFreePtr)\r\n            }\r\n        }\r\n        if (!success) {\r\n            bytes32 innerRevertCode;\r\n            assembly (\"memory-safe\") {\r\n                let len := returndatasize()\r\n                if eq(32,len) {\r\n                    returndatacopy(0, 0, 32)\r\n                    innerRevertCode := mload(0)\r\n                }\r\n            }\r\n            if (innerRevertCode == INNER_OUT_OF_GAS) {\r\n                // handleOps was called with gas limit too low. abort entire bundle.\r\n                //can only be caused by bundler (leaving not enough gas for inner call)\r\n                revert FailedOp(opIndex, \"AA95 out of gas\");\r\n            } else if (innerRevertCode == INNER_REVERT_LOW_PREFUND) {\r\n                // innerCall reverted on prefund too low. treat entire prefund as \"gas cost\"\r\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\r\n                uint256 actualGasCost = opInfo.prefund;\r\n                emitPrefundTooLow(opInfo);\r\n                emitUserOperationEvent(opInfo, false, actualGasCost, actualGas);\r\n                collected = actualGasCost;\r\n            } else {\r\n                emit PostOpRevertReason(\r\n                    opInfo.userOpHash,\r\n                    opInfo.mUserOp.sender,\r\n                    opInfo.mUserOp.nonce,\r\n                    Exec.getReturnData(REVERT_REASON_MAX_LEN)\r\n                );\r\n\r\n                uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\r\n                collected = _postExecution(\r\n                    IPaymaster.PostOpMode.postOpReverted,\r\n                    opInfo,\r\n                    context,\r\n                    actualGas\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function emitUserOperationEvent(UserOpInfo memory opInfo, bool success, uint256 actualGasCost, uint256 actualGas) internal virtual {\r\n        emit UserOperationEvent(\r\n            opInfo.userOpHash,\r\n            opInfo.mUserOp.sender,\r\n            opInfo.mUserOp.paymaster,\r\n            opInfo.mUserOp.nonce,\r\n            success,\r\n            actualGasCost,\r\n            actualGas\r\n        );\r\n    }\r\n\r\n    function emitPrefundTooLow(UserOpInfo memory opInfo) internal virtual {\r\n        emit UserOperationPrefundTooLow(\r\n            opInfo.userOpHash,\r\n            opInfo.mUserOp.sender,\r\n            opInfo.mUserOp.nonce\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IEntryPoint\r\n    function handleOps(\r\n        PackedUserOperation[] calldata ops,\r\n        address payable beneficiary\r\n    ) public nonReentrant {\r\n        uint256 opslen = ops.length;\r\n        UserOpInfo[] memory opInfos = new UserOpInfo[](opslen);\r\n\r\n        unchecked {\r\n            for (uint256 i = 0; i < opslen; i++) {\r\n                UserOpInfo memory opInfo = opInfos[i];\r\n                (\r\n                    uint256 validationData,\r\n                    uint256 pmValidationData\r\n                ) = _validatePrepayment(i, ops[i], opInfo);\r\n                _validateAccountAndPaymasterValidationData(\r\n                    i,\r\n                    validationData,\r\n                    pmValidationData,\r\n                    address(0)\r\n                );\r\n            }\r\n\r\n            uint256 collected = 0;\r\n            emit BeforeExecution();\r\n\r\n            for (uint256 i = 0; i < opslen; i++) {\r\n                collected += _executeUserOp(i, ops[i], opInfos[i]);\r\n            }\r\n\r\n            _compensate(beneficiary, collected);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IEntryPoint\r\n    function handleAggregatedOps(\r\n        UserOpsPerAggregator[] calldata opsPerAggregator,\r\n        address payable beneficiary\r\n    ) public nonReentrant {\r\n\r\n        uint256 opasLen = opsPerAggregator.length;\r\n        uint256 totalOps = 0;\r\n        for (uint256 i = 0; i < opasLen; i++) {\r\n            UserOpsPerAggregator calldata opa = opsPerAggregator[i];\r\n            PackedUserOperation[] calldata ops = opa.userOps;\r\n            IAggregator aggregator = opa.aggregator;\r\n\r\n            //address(1) is special marker of \"signature error\"\r\n            require(\r\n                address(aggregator) != address(1),\r\n                \"AA96 invalid aggregator\"\r\n            );\r\n\r\n            if (address(aggregator) != address(0)) {\r\n                // solhint-disable-next-line no-empty-blocks\r\n                try aggregator.validateSignatures(ops, opa.signature) {} catch {\r\n                    revert SignatureValidationFailed(address(aggregator));\r\n                }\r\n            }\r\n\r\n            totalOps += ops.length;\r\n        }\r\n\r\n        UserOpInfo[] memory opInfos = new UserOpInfo[](totalOps);\r\n\r\n        uint256 opIndex = 0;\r\n        for (uint256 a = 0; a < opasLen; a++) {\r\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\r\n            PackedUserOperation[] calldata ops = opa.userOps;\r\n            IAggregator aggregator = opa.aggregator;\r\n\r\n            uint256 opslen = ops.length;\r\n            for (uint256 i = 0; i < opslen; i++) {\r\n                UserOpInfo memory opInfo = opInfos[opIndex];\r\n                (\r\n                    uint256 validationData,\r\n                    uint256 paymasterValidationData\r\n                ) = _validatePrepayment(opIndex, ops[i], opInfo);\r\n                _validateAccountAndPaymasterValidationData(\r\n                    i,\r\n                    validationData,\r\n                    paymasterValidationData,\r\n                    address(aggregator)\r\n                );\r\n                opIndex++;\r\n            }\r\n        }\r\n\r\n        emit BeforeExecution();\r\n\r\n        uint256 collected = 0;\r\n        opIndex = 0;\r\n        for (uint256 a = 0; a < opasLen; a++) {\r\n            UserOpsPerAggregator calldata opa = opsPerAggregator[a];\r\n            emit SignatureAggregatorChanged(address(opa.aggregator));\r\n            PackedUserOperation[] calldata ops = opa.userOps;\r\n            uint256 opslen = ops.length;\r\n\r\n            for (uint256 i = 0; i < opslen; i++) {\r\n                collected += _executeUserOp(opIndex, ops[i], opInfos[opIndex]);\r\n                opIndex++;\r\n            }\r\n        }\r\n        emit SignatureAggregatorChanged(address(0));\r\n\r\n        _compensate(beneficiary, collected);\r\n    }\r\n\r\n    /**\r\n     * A memory copy of UserOp static fields only.\r\n     * Excluding: callData, initCode and signature. Replacing paymasterAndData with paymaster.\r\n     */\r\n    struct MemoryUserOp {\r\n        address sender;\r\n        uint256 nonce;\r\n        uint256 verificationGasLimit;\r\n        uint256 callGasLimit;\r\n        uint256 paymasterVerificationGasLimit;\r\n        uint256 paymasterPostOpGasLimit;\r\n        uint256 preVerificationGas;\r\n        address paymaster;\r\n        uint256 maxFeePerGas;\r\n        uint256 maxPriorityFeePerGas;\r\n    }\r\n\r\n    struct UserOpInfo {\r\n        MemoryUserOp mUserOp;\r\n        bytes32 userOpHash;\r\n        uint256 prefund;\r\n        uint256 contextOffset;\r\n        uint256 preOpGas;\r\n    }\r\n\r\n    /**\r\n     * Inner function to handle a UserOperation.\r\n     * Must be declared \"external\" to open a call context, but it can only be called by handleOps.\r\n     * @param callData - The callData to execute.\r\n     * @param opInfo   - The UserOpInfo struct.\r\n     * @param context  - The context bytes.\r\n     * @return actualGasCost - the actual cost in eth this UserOperation paid for gas\r\n     */\r\n    function innerHandleOp(\r\n        bytes memory callData,\r\n        UserOpInfo memory opInfo,\r\n        bytes calldata context\r\n    ) external returns (uint256 actualGasCost) {\r\n        uint256 preGas = gasleft();\r\n        require(msg.sender == address(this), \"AA92 internal call only\");\r\n        MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\n\r\n        uint256 callGasLimit = mUserOp.callGasLimit;\r\n        unchecked {\r\n            // handleOps was called with gas limit too low. abort entire bundle.\r\n            if (\r\n                gasleft() * 63 / 64 <\r\n                callGasLimit +\r\n                mUserOp.paymasterPostOpGasLimit +\r\n                INNER_GAS_OVERHEAD\r\n            ) {\r\n                assembly (\"memory-safe\") {\r\n                    mstore(0, INNER_OUT_OF_GAS)\r\n                    revert(0, 32)\r\n                }\r\n            }\r\n        }\r\n\r\n        IPaymaster.PostOpMode mode = IPaymaster.PostOpMode.opSucceeded;\r\n        if (callData.length > 0) {\r\n            bool success = Exec.call(mUserOp.sender, 0, callData, callGasLimit);\r\n            if (!success) {\r\n                bytes memory result = Exec.getReturnData(REVERT_REASON_MAX_LEN);\r\n                if (result.length > 0) {\r\n                    emit UserOperationRevertReason(\r\n                        opInfo.userOpHash,\r\n                        mUserOp.sender,\r\n                        mUserOp.nonce,\r\n                        result\r\n                    );\r\n                }\r\n                mode = IPaymaster.PostOpMode.opReverted;\r\n            }\r\n        }\r\n\r\n        unchecked {\r\n            uint256 actualGas = preGas - gasleft() + opInfo.preOpGas;\r\n            return _postExecution(mode, opInfo, context, actualGas);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IEntryPoint\r\n    function getUserOpHash(\r\n        PackedUserOperation calldata userOp\r\n    ) public view returns (bytes32) {\r\n        return\r\n            keccak256(abi.encode(userOp.hash(), address(this), block.chainid));\r\n    }\r\n\r\n    /**\r\n     * Copy general fields from userOp into the memory opInfo structure.\r\n     * @param userOp  - The user operation.\r\n     * @param mUserOp - The memory user operation.\r\n     */\r\n    function _copyUserOpToMemory(\r\n        PackedUserOperation calldata userOp,\r\n        MemoryUserOp memory mUserOp\r\n    ) internal pure {\r\n        mUserOp.sender = userOp.sender;\r\n        mUserOp.nonce = userOp.nonce;\r\n        (mUserOp.verificationGasLimit, mUserOp.callGasLimit) = UserOperationLib.unpackUints(userOp.accountGasLimits);\r\n        mUserOp.preVerificationGas = userOp.preVerificationGas;\r\n        (mUserOp.maxPriorityFeePerGas, mUserOp.maxFeePerGas) = UserOperationLib.unpackUints(userOp.gasFees);\r\n        bytes calldata paymasterAndData = userOp.paymasterAndData;\r\n        if (paymasterAndData.length > 0) {\r\n            require(\r\n                paymasterAndData.length >= UserOperationLib.PAYMASTER_DATA_OFFSET,\r\n                \"AA93 invalid paymasterAndData\"\r\n            );\r\n            (mUserOp.paymaster, mUserOp.paymasterVerificationGasLimit, mUserOp.paymasterPostOpGasLimit) = UserOperationLib.unpackPaymasterStaticFields(paymasterAndData);\r\n        } else {\r\n            mUserOp.paymaster = address(0);\r\n            mUserOp.paymasterVerificationGasLimit = 0;\r\n            mUserOp.paymasterPostOpGasLimit = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the required prefunded gas fee amount for an operation.\r\n     * @param mUserOp - The user operation in memory.\r\n     */\r\n    function _getRequiredPrefund(\r\n        MemoryUserOp memory mUserOp\r\n    ) internal pure returns (uint256 requiredPrefund) {\r\n        unchecked {\r\n            uint256 requiredGas = mUserOp.verificationGasLimit +\r\n                mUserOp.callGasLimit +\r\n                mUserOp.paymasterVerificationGasLimit +\r\n                mUserOp.paymasterPostOpGasLimit +\r\n                mUserOp.preVerificationGas;\r\n\r\n            requiredPrefund = requiredGas * mUserOp.maxFeePerGas;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create sender smart contract account if init code is provided.\r\n     * @param opIndex  - The operation index.\r\n     * @param opInfo   - The operation info.\r\n     * @param initCode - The init code for the smart contract account.\r\n     */\r\n    function _createSenderIfNeeded(\r\n        uint256 opIndex,\r\n        UserOpInfo memory opInfo,\r\n        bytes calldata initCode\r\n    ) internal {\r\n        if (initCode.length != 0) {\r\n            address sender = opInfo.mUserOp.sender;\r\n            if (sender.code.length != 0)\r\n                revert FailedOp(opIndex, \"AA10 sender already constructed\");\r\n            address sender1 = senderCreator().createSender{\r\n                gas: opInfo.mUserOp.verificationGasLimit\r\n            }(initCode);\r\n            if (sender1 == address(0))\r\n                revert FailedOp(opIndex, \"AA13 initCode failed or OOG\");\r\n            if (sender1 != sender)\r\n                revert FailedOp(opIndex, \"AA14 initCode must return sender\");\r\n            if (sender1.code.length == 0)\r\n                revert FailedOp(opIndex, \"AA15 initCode must create sender\");\r\n            address factory = address(bytes20(initCode[0:20]));\r\n            emit AccountDeployed(\r\n                opInfo.userOpHash,\r\n                sender,\r\n                factory,\r\n                opInfo.mUserOp.paymaster\r\n            );\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IEntryPoint\r\n    function getSenderAddress(bytes calldata initCode) public {\r\n        address sender = senderCreator().createSender(initCode);\r\n        revert SenderAddressResult(sender);\r\n    }\r\n\r\n    /**\r\n     * Call account.validateUserOp.\r\n     * Revert (with FailedOp) in case validateUserOp reverts, or account didn't send required prefund.\r\n     * Decrement account's deposit if needed.\r\n     * @param opIndex         - The operation index.\r\n     * @param op              - The user operation.\r\n     * @param opInfo          - The operation info.\r\n     * @param requiredPrefund - The required prefund amount.\r\n     */\r\n    function _validateAccountPrepayment(\r\n        uint256 opIndex,\r\n        PackedUserOperation calldata op,\r\n        UserOpInfo memory opInfo,\r\n        uint256 requiredPrefund,\r\n        uint256 verificationGasLimit\r\n    )\r\n        internal\r\n        returns (\r\n            uint256 validationData\r\n        )\r\n    {\r\n        unchecked {\r\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\n            address sender = mUserOp.sender;\r\n            _createSenderIfNeeded(opIndex, opInfo, op.initCode);\r\n            address paymaster = mUserOp.paymaster;\r\n            uint256 missingAccountFunds = 0;\r\n            if (paymaster == address(0)) {\r\n                uint256 bal = balanceOf(sender);\r\n                missingAccountFunds = bal > requiredPrefund\r\n                    ? 0\r\n                    : requiredPrefund - bal;\r\n            }\r\n            try\r\n                IAccount(sender).validateUserOp{\r\n                    gas: verificationGasLimit\r\n                }(op, opInfo.userOpHash, missingAccountFunds)\r\n            returns (uint256 _validationData) {\r\n                validationData = _validationData;\r\n            } catch {\r\n                revert FailedOpWithRevert(opIndex, \"AA23 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\r\n            }\r\n            if (paymaster == address(0)) {\r\n                DepositInfo storage senderInfo = deposits[sender];\r\n                uint256 deposit = senderInfo.deposit;\r\n                if (requiredPrefund > deposit) {\r\n                    revert FailedOp(opIndex, \"AA21 didn't pay prefund\");\r\n                }\r\n                senderInfo.deposit = deposit - requiredPrefund;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case the request has a paymaster:\r\n     *  - Validate paymaster has enough deposit.\r\n     *  - Call paymaster.validatePaymasterUserOp.\r\n     *  - Revert with proper FailedOp in case paymaster reverts.\r\n     *  - Decrement paymaster's deposit.\r\n     * @param opIndex                            - The operation index.\r\n     * @param op                                 - The user operation.\r\n     * @param opInfo                             - The operation info.\r\n     * @param requiredPreFund                    - The required prefund amount.\r\n     */\r\n    function _validatePaymasterPrepayment(\r\n        uint256 opIndex,\r\n        PackedUserOperation calldata op,\r\n        UserOpInfo memory opInfo,\r\n        uint256 requiredPreFund\r\n    ) internal returns (bytes memory context, uint256 validationData) {\r\n        unchecked {\r\n            uint256 preGas = gasleft();\r\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\n            address paymaster = mUserOp.paymaster;\r\n            DepositInfo storage paymasterInfo = deposits[paymaster];\r\n            uint256 deposit = paymasterInfo.deposit;\r\n            if (deposit < requiredPreFund) {\r\n                revert FailedOp(opIndex, \"AA31 paymaster deposit too low\");\r\n            }\r\n            paymasterInfo.deposit = deposit - requiredPreFund;\r\n            uint256 pmVerificationGasLimit = mUserOp.paymasterVerificationGasLimit;\r\n            try\r\n                IPaymaster(paymaster).validatePaymasterUserOp{gas: pmVerificationGasLimit}(\r\n                    op,\r\n                    opInfo.userOpHash,\r\n                    requiredPreFund\r\n                )\r\n            returns (bytes memory _context, uint256 _validationData) {\r\n                context = _context;\r\n                validationData = _validationData;\r\n            } catch {\r\n                revert FailedOpWithRevert(opIndex, \"AA33 reverted\", Exec.getReturnData(REVERT_REASON_MAX_LEN));\r\n            }\r\n            if (preGas - gasleft() > pmVerificationGasLimit) {\r\n                revert FailedOp(opIndex, \"AA36 over paymasterVerificationGasLimit\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Revert if either account validationData or paymaster validationData is expired.\r\n     * @param opIndex                 - The operation index.\r\n     * @param validationData          - The account validationData.\r\n     * @param paymasterValidationData - The paymaster validationData.\r\n     * @param expectedAggregator      - The expected aggregator.\r\n     */\r\n    function _validateAccountAndPaymasterValidationData(\r\n        uint256 opIndex,\r\n        uint256 validationData,\r\n        uint256 paymasterValidationData,\r\n        address expectedAggregator\r\n    ) internal view {\r\n        (address aggregator, bool outOfTimeRange) = _getValidationData(\r\n            validationData\r\n        );\r\n        if (expectedAggregator != aggregator) {\r\n            revert FailedOp(opIndex, \"AA24 signature error\");\r\n        }\r\n        if (outOfTimeRange) {\r\n            revert FailedOp(opIndex, \"AA22 expired or not due\");\r\n        }\r\n        // pmAggregator is not a real signature aggregator: we don't have logic to handle it as address.\r\n        // Non-zero address means that the paymaster fails due to some signature check (which is ok only during estimation).\r\n        address pmAggregator;\r\n        (pmAggregator, outOfTimeRange) = _getValidationData(\r\n            paymasterValidationData\r\n        );\r\n        if (pmAggregator != address(0)) {\r\n            revert FailedOp(opIndex, \"AA34 signature error\");\r\n        }\r\n        if (outOfTimeRange) {\r\n            revert FailedOp(opIndex, \"AA32 paymaster expired or not due\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parse validationData into its components.\r\n     * @param validationData - The packed validation data (sigFailed, validAfter, validUntil).\r\n     * @return aggregator the aggregator of the validationData\r\n     * @return outOfTimeRange true if current time is outside the time range of this validationData.\r\n     */\r\n    function _getValidationData(\r\n        uint256 validationData\r\n    ) internal view returns (address aggregator, bool outOfTimeRange) {\r\n        if (validationData == 0) {\r\n            return (address(0), false);\r\n        }\r\n        ValidationData memory data = _parseValidationData(validationData);\r\n        // solhint-disable-next-line not-rely-on-time\r\n        outOfTimeRange = block.timestamp > data.validUntil || block.timestamp < data.validAfter;\r\n        aggregator = data.aggregator;\r\n    }\r\n\r\n    /**\r\n     * Validate account and paymaster (if defined) and\r\n     * also make sure total validation doesn't exceed verificationGasLimit.\r\n     * This method is called off-chain (simulateValidation()) and on-chain (from handleOps)\r\n     * @param opIndex - The index of this userOp into the \"opInfos\" array.\r\n     * @param userOp  - The userOp to validate.\r\n     */\r\n    function _validatePrepayment(\r\n        uint256 opIndex,\r\n        PackedUserOperation calldata userOp,\r\n        UserOpInfo memory outOpInfo\r\n    )\r\n        internal\r\n        returns (uint256 validationData, uint256 paymasterValidationData)\r\n    {\r\n        uint256 preGas = gasleft();\r\n        MemoryUserOp memory mUserOp = outOpInfo.mUserOp;\r\n        _copyUserOpToMemory(userOp, mUserOp);\r\n        outOpInfo.userOpHash = getUserOpHash(userOp);\r\n\r\n        // Validate all numeric values in userOp are well below 128 bit, so they can safely be added\r\n        // and multiplied without causing overflow.\r\n        uint256 verificationGasLimit = mUserOp.verificationGasLimit;\r\n        uint256 maxGasValues = mUserOp.preVerificationGas |\r\n            verificationGasLimit |\r\n            mUserOp.callGasLimit |\r\n            mUserOp.paymasterVerificationGasLimit |\r\n            mUserOp.paymasterPostOpGasLimit |\r\n            mUserOp.maxFeePerGas |\r\n            mUserOp.maxPriorityFeePerGas;\r\n        require(maxGasValues <= type(uint120).max, \"AA94 gas values overflow\");\r\n\r\n        uint256 requiredPreFund = _getRequiredPrefund(mUserOp);\r\n        validationData = _validateAccountPrepayment(\r\n            opIndex,\r\n            userOp,\r\n            outOpInfo,\r\n            requiredPreFund,\r\n            verificationGasLimit\r\n        );\r\n\r\n        if (!_validateAndUpdateNonce(mUserOp.sender, mUserOp.nonce)) {\r\n            revert FailedOp(opIndex, \"AA25 invalid account nonce\");\r\n        }\r\n\r\n        unchecked {\r\n            if (preGas - gasleft() > verificationGasLimit) {\r\n                revert FailedOp(opIndex, \"AA26 over verificationGasLimit\");\r\n            }\r\n        }\r\n\r\n        bytes memory context;\r\n        if (mUserOp.paymaster != address(0)) {\r\n            (context, paymasterValidationData) = _validatePaymasterPrepayment(\r\n                opIndex,\r\n                userOp,\r\n                outOpInfo,\r\n                requiredPreFund\r\n            );\r\n        }\r\n        unchecked {\r\n            outOpInfo.prefund = requiredPreFund;\r\n            outOpInfo.contextOffset = getOffsetOfMemoryBytes(context);\r\n            outOpInfo.preOpGas = preGas - gasleft() + userOp.preVerificationGas;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process post-operation, called just after the callData is executed.\r\n     * If a paymaster is defined and its validation returned a non-empty context, its postOp is called.\r\n     * The excess amount is refunded to the account (or paymaster - if it was used in the request).\r\n     * @param mode      - Whether is called from innerHandleOp, or outside (postOpReverted).\r\n     * @param opInfo    - UserOp fields and info collected during validation.\r\n     * @param context   - The context returned in validatePaymasterUserOp.\r\n     * @param actualGas - The gas used so far by this user operation.\r\n     */\r\n    function _postExecution(\r\n        IPaymaster.PostOpMode mode,\r\n        UserOpInfo memory opInfo,\r\n        bytes memory context,\r\n        uint256 actualGas\r\n    ) private returns (uint256 actualGasCost) {\r\n        uint256 preGas = gasleft();\r\n        unchecked {\r\n            address refundAddress;\r\n            MemoryUserOp memory mUserOp = opInfo.mUserOp;\r\n            uint256 gasPrice = getUserOpGasPrice(mUserOp);\r\n\r\n            address paymaster = mUserOp.paymaster;\r\n            if (paymaster == address(0)) {\r\n                refundAddress = mUserOp.sender;\r\n            } else {\r\n                refundAddress = paymaster;\r\n                if (context.length > 0) {\r\n                    actualGasCost = actualGas * gasPrice;\r\n                    if (mode != IPaymaster.PostOpMode.postOpReverted) {\r\n                        try IPaymaster(paymaster).postOp{\r\n                            gas: mUserOp.paymasterPostOpGasLimit\r\n                        }(mode, context, actualGasCost, gasPrice)\r\n                        // solhint-disable-next-line no-empty-blocks\r\n                        {} catch {\r\n                            bytes memory reason = Exec.getReturnData(REVERT_REASON_MAX_LEN);\r\n                            revert PostOpReverted(reason);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            actualGas += preGas - gasleft();\r\n\r\n            // Calculating a penalty for unused execution gas\r\n            {\r\n                uint256 executionGasLimit = mUserOp.callGasLimit + mUserOp.paymasterPostOpGasLimit;\r\n                uint256 executionGasUsed = actualGas - opInfo.preOpGas;\r\n                // this check is required for the gas used within EntryPoint and not covered by explicit gas limits\r\n                if (executionGasLimit > executionGasUsed) {\r\n                    uint256 unusedGas = executionGasLimit - executionGasUsed;\r\n                    uint256 unusedGasPenalty = (unusedGas * PENALTY_PERCENT) / 100;\r\n                    actualGas += unusedGasPenalty;\r\n                }\r\n            }\r\n\r\n            actualGasCost = actualGas * gasPrice;\r\n            uint256 prefund = opInfo.prefund;\r\n            if (prefund < actualGasCost) {\r\n                if (mode == IPaymaster.PostOpMode.postOpReverted) {\r\n                    actualGasCost = prefund;\r\n                    emitPrefundTooLow(opInfo);\r\n                    emitUserOperationEvent(opInfo, false, actualGasCost, actualGas);\r\n                } else {\r\n                    assembly (\"memory-safe\") {\r\n                        mstore(0, INNER_REVERT_LOW_PREFUND)\r\n                        revert(0, 32)\r\n                    }\r\n                }\r\n            } else {\r\n                uint256 refund = prefund - actualGasCost;\r\n                _incrementDeposit(refundAddress, refund);\r\n                bool success = mode == IPaymaster.PostOpMode.opSucceeded;\r\n                emitUserOperationEvent(opInfo, success, actualGasCost, actualGas);\r\n            }\r\n        } // unchecked\r\n    }\r\n\r\n    /**\r\n     * The gas price this UserOp agrees to pay.\r\n     * Relayer/block builder might submit the TX with higher priorityFee, but the user should not.\r\n     * @param mUserOp - The userOp to get the gas price from.\r\n     */\r\n    function getUserOpGasPrice(\r\n        MemoryUserOp memory mUserOp\r\n    ) internal view returns (uint256) {\r\n        unchecked {\r\n            uint256 maxFeePerGas = mUserOp.maxFeePerGas;\r\n            uint256 maxPriorityFeePerGas = mUserOp.maxPriorityFeePerGas;\r\n            if (maxFeePerGas == maxPriorityFeePerGas) {\r\n                //legacy mode (for networks that don't support basefee opcode)\r\n                return maxFeePerGas;\r\n            }\r\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The offset of the given bytes in memory.\r\n     * @param data - The bytes to get the offset of.\r\n     */\r\n    function getOffsetOfMemoryBytes(\r\n        bytes memory data\r\n    ) internal pure returns (uint256 offset) {\r\n        assembly {\r\n            offset := data\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The bytes in memory at the given offset.\r\n     * @param offset - The offset to get the bytes from.\r\n     */\r\n    function getMemoryBytesFromOffset(\r\n        uint256 offset\r\n    ) internal pure returns (bytes memory data) {\r\n        assembly (\"memory-safe\") {\r\n            data := offset\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IEntryPoint\r\n    function delegateAndRevert(address target, bytes calldata data) external {\r\n        (bool success, bytes memory ret) = target.delegatecall(data);\r\n        revert DelegateAndRevert(success, ret);\r\n    }\r\n}\r\n"
    },
    "contracts/core/EntryPointSimulations.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable no-inline-assembly */\r\n\r\nimport \"./EntryPoint.sol\";\r\nimport \"../interfaces/IEntryPointSimulations.sol\";\r\n\r\n/*\r\n * This contract inherits the EntryPoint and extends it with the view-only methods that are executed by\r\n * the bundler in order to check UserOperation validity and estimate its gas consumption.\r\n * This contract should never be deployed on-chain and is only used as a parameter for the \"eth_call\" request.\r\n */\r\ncontract EntryPointSimulations is EntryPoint, IEntryPointSimulations {\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    AggregatorStakeInfo private NOT_AGGREGATED = AggregatorStakeInfo(address(0), StakeInfo(0, 0));\r\n\r\n    SenderCreator private _senderCreator;\r\n\r\n    function initSenderCreator() internal virtual {\r\n        //this is the address of the first contract created with CREATE by this address.\r\n        address createdObj = address(uint160(uint256(keccak256(abi.encodePacked(hex\"d694\", address(this), hex\"01\")))));\r\n        _senderCreator = SenderCreator(createdObj);\r\n    }\r\n\r\n    function senderCreator() internal view virtual override returns (SenderCreator) {\r\n        // return the same senderCreator as real EntryPoint.\r\n        // this call is slightly (100) more expensive than EntryPoint's access to immutable member\r\n        return _senderCreator;\r\n    }\r\n\r\n    /**\r\n     * simulation contract should not be deployed, and specifically, accounts should not trust\r\n     * it as entrypoint, since the simulation functions don't check the signatures\r\n     */\r\n    constructor() {\r\n        require(block.number < 100, \"should not be deployed\");\r\n    }\r\n\r\n    /// @inheritdoc IEntryPointSimulations\r\n    function simulateValidation(\r\n        PackedUserOperation calldata userOp\r\n    )\r\n    external\r\n    returns (\r\n        ValidationResult memory\r\n    ){\r\n        UserOpInfo memory outOpInfo;\r\n\r\n        _simulationOnlyValidations(userOp);\r\n        (\r\n            uint256 validationData,\r\n            uint256 paymasterValidationData\r\n        ) = _validatePrepayment(0, userOp, outOpInfo);\r\n        StakeInfo memory paymasterInfo = _getStakeInfo(\r\n            outOpInfo.mUserOp.paymaster\r\n        );\r\n        StakeInfo memory senderInfo = _getStakeInfo(outOpInfo.mUserOp.sender);\r\n        StakeInfo memory factoryInfo;\r\n        {\r\n            bytes calldata initCode = userOp.initCode;\r\n            address factory = initCode.length >= 20\r\n                ? address(bytes20(initCode[0 : 20]))\r\n                : address(0);\r\n            factoryInfo = _getStakeInfo(factory);\r\n        }\r\n\r\n        address aggregator = address(uint160(validationData));\r\n        ReturnInfo memory returnInfo = ReturnInfo(\r\n            outOpInfo.preOpGas,\r\n            outOpInfo.prefund,\r\n            validationData,\r\n            paymasterValidationData,\r\n            getMemoryBytesFromOffset(outOpInfo.contextOffset)\r\n        );\r\n\r\n        AggregatorStakeInfo memory aggregatorInfo = NOT_AGGREGATED;\r\n        if (uint160(aggregator) != SIG_VALIDATION_SUCCESS && uint160(aggregator) != SIG_VALIDATION_FAILED) {\r\n            aggregatorInfo = AggregatorStakeInfo(\r\n                aggregator,\r\n                _getStakeInfo(aggregator)\r\n            );\r\n        }\r\n        return ValidationResult(\r\n            returnInfo,\r\n            senderInfo,\r\n            factoryInfo,\r\n            paymasterInfo,\r\n            aggregatorInfo\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IEntryPointSimulations\r\n    function simulateHandleOp(\r\n        PackedUserOperation calldata op,\r\n        address target,\r\n        bytes calldata targetCallData\r\n    )\r\n    external nonReentrant\r\n    returns (\r\n        ExecutionResult memory\r\n    ){\r\n        UserOpInfo memory opInfo;\r\n        _simulationOnlyValidations(op);\r\n        (\r\n            uint256 validationData,\r\n            uint256 paymasterValidationData\r\n        ) = _validatePrepayment(0, op, opInfo);\r\n\r\n        uint256 paid = _executeUserOp(0, op, opInfo);\r\n        bool targetSuccess;\r\n        bytes memory targetResult;\r\n        if (target != address(0)) {\r\n            (targetSuccess, targetResult) = target.call(targetCallData);\r\n        }\r\n        return ExecutionResult(\r\n            opInfo.preOpGas,\r\n            paid,\r\n            validationData,\r\n            paymasterValidationData,\r\n            targetSuccess,\r\n            targetResult\r\n        );\r\n    }\r\n\r\n    function _simulationOnlyValidations(\r\n        PackedUserOperation calldata userOp\r\n    )\r\n    internal\r\n    {\r\n        //initialize senderCreator(). we can't rely on constructor\r\n        initSenderCreator();\r\n\r\n        try\r\n        this._validateSenderAndPaymaster(\r\n            userOp.initCode,\r\n            userOp.sender,\r\n            userOp.paymasterAndData\r\n        )\r\n        // solhint-disable-next-line no-empty-blocks\r\n        {} catch Error(string memory revertReason) {\r\n            if (bytes(revertReason).length != 0) {\r\n                revert FailedOp(0, revertReason);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called only during simulation.\r\n     * This function always reverts to prevent warm/cold storage differentiation in simulation vs execution.\r\n     * @param initCode         - The smart account constructor code.\r\n     * @param sender           - The sender address.\r\n     * @param paymasterAndData - The paymaster address (followed by other params, ignored by this method)\r\n     */\r\n    function _validateSenderAndPaymaster(\r\n        bytes calldata initCode,\r\n        address sender,\r\n        bytes calldata paymasterAndData\r\n    ) external view {\r\n        if (initCode.length == 0 && sender.code.length == 0) {\r\n            // it would revert anyway. but give a meaningful message\r\n            revert(\"AA20 account not deployed\");\r\n        }\r\n        if (paymasterAndData.length >= 20) {\r\n            address paymaster = address(bytes20(paymasterAndData[0 : 20]));\r\n            if (paymaster.code.length == 0) {\r\n                // It would revert anyway. but give a meaningful message.\r\n                revert(\"AA30 paymaster not deployed\");\r\n            }\r\n        }\r\n        // always revert\r\n        revert(\"\");\r\n    }\r\n\r\n    //make sure depositTo cost is more than normal EntryPoint's cost,\r\n    // to mitigate DoS vector on the bundler\r\n    // empiric test showed that without this wrapper, simulation depositTo costs less..\r\n    function depositTo(address account) public override(IStakeManager, StakeManager) payable {\r\n        unchecked{\r\n        // silly code, to waste some gas to make sure depositTo is always little more\r\n        // expensive than on-chain call\r\n            uint256 x = 1;\r\n            while (x < 5) {\r\n                x++;\r\n            }\r\n            StakeManager.depositTo(account);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\n/* solhint-disable no-inline-assembly */\r\n\r\n\r\n /*\r\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\r\n  * must return this value in case of signature failure, instead of revert.\r\n  */\r\nuint256 constant SIG_VALIDATION_FAILED = 1;\r\n\r\n\r\n/*\r\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\r\n * return this value on success.\r\n */\r\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\r\n\r\n\r\n/**\r\n * Returned data from validateUserOp.\r\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\r\n * parsed by `_parseValidationData`.\r\n * @param aggregator  - address(0) - The account validated the signature by itself.\r\n *                      address(1) - The account failed to validate the signature.\r\n *                      otherwise - This is an address of a signature aggregator that must\r\n *                                  be used to validate the signature.\r\n * @param validAfter  - This UserOp is valid only after this timestamp.\r\n * @param validaUntil - This UserOp is valid only up to this timestamp.\r\n */\r\nstruct ValidationData {\r\n    address aggregator;\r\n    uint48 validAfter;\r\n    uint48 validUntil;\r\n}\r\n\r\n/**\r\n * Extract sigFailed, validAfter, validUntil.\r\n * Also convert zero validUntil to type(uint48).max.\r\n * @param validationData - The packed validation data.\r\n */\r\nfunction _parseValidationData(\r\n    uint256 validationData\r\n) pure returns (ValidationData memory data) {\r\n    address aggregator = address(uint160(validationData));\r\n    uint48 validUntil = uint48(validationData >> 160);\r\n    if (validUntil == 0) {\r\n        validUntil = type(uint48).max;\r\n    }\r\n    uint48 validAfter = uint48(validationData >> (48 + 160));\r\n    return ValidationData(aggregator, validAfter, validUntil);\r\n}\r\n\r\n/**\r\n * Helper to pack the return value for validateUserOp.\r\n * @param data - The ValidationData to pack.\r\n */\r\nfunction _packValidationData(\r\n    ValidationData memory data\r\n) pure returns (uint256) {\r\n    return\r\n        uint160(data.aggregator) |\r\n        (uint256(data.validUntil) << 160) |\r\n        (uint256(data.validAfter) << (160 + 48));\r\n}\r\n\r\n/**\r\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\r\n * @param sigFailed  - True for signature failure, false for success.\r\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\r\n * @param validAfter - First timestamp this UserOperation is valid.\r\n */\r\nfunction _packValidationData(\r\n    bool sigFailed,\r\n    uint48 validUntil,\r\n    uint48 validAfter\r\n) pure returns (uint256) {\r\n    return\r\n        (sigFailed ? 1 : 0) |\r\n        (uint256(validUntil) << 160) |\r\n        (uint256(validAfter) << (160 + 48));\r\n}\r\n\r\n/**\r\n * keccak function over calldata.\r\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\r\n */\r\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\r\n        assembly (\"memory-safe\") {\r\n            let mem := mload(0x40)\r\n            let len := data.length\r\n            calldatacopy(mem, data.offset, len)\r\n            ret := keccak256(mem, len)\r\n        }\r\n    }\r\n\r\n\r\n/**\r\n * The minimum of two numbers.\r\n * @param a - First number.\r\n * @param b - Second number.\r\n */\r\n    function min(uint256 a, uint256 b) pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n"
    },
    "contracts/core/NonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\nimport \"../interfaces/INonceManager.sol\";\r\n\r\n/**\r\n * nonce management functionality\r\n */\r\nabstract contract NonceManager is INonceManager {\r\n\r\n    /**\r\n     * The next valid sequence number for a given nonce key.\r\n     */\r\n    mapping(address => mapping(uint192 => uint256)) public nonceSequenceNumber;\r\n\r\n    /// @inheritdoc INonceManager\r\n    function getNonce(address sender, uint192 key)\r\n    public view override returns (uint256 nonce) {\r\n        return nonceSequenceNumber[sender][key] | (uint256(key) << 64);\r\n    }\r\n\r\n    // allow an account to manually increment its own nonce.\r\n    // (mainly so that during construction nonce can be made non-zero,\r\n    // to \"absorb\" the gas cost of first nonce increment to 1st transaction (construction),\r\n    // not to 2nd transaction)\r\n    function incrementNonce(uint192 key) public override {\r\n        nonceSequenceNumber[msg.sender][key]++;\r\n    }\r\n\r\n    /**\r\n     * validate nonce uniqueness for this account.\r\n     * called just after validateUserOp()\r\n     * @return true if the nonce was incremented successfully.\r\n     *         false if the current nonce doesn't match the given one.\r\n     */\r\n    function _validateAndUpdateNonce(address sender, uint256 nonce) internal returns (bool) {\r\n\r\n        uint192 key = uint192(nonce >> 64);\r\n        uint64 seq = uint64(nonce);\r\n        return nonceSequenceNumber[sender][key]++ == seq;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/core/SenderCreator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\n/**\r\n * Helper contract for EntryPoint, to call userOp.initCode from a \"neutral\" address,\r\n * which is explicitly not the entryPoint itself.\r\n */\r\ncontract SenderCreator {\r\n    /**\r\n     * Call the \"initCode\" factory to create and return the sender account address.\r\n     * @param initCode - The initCode value from a UserOp. contains 20 bytes of factory address,\r\n     *                   followed by calldata.\r\n     * @return sender  - The returned address of the created account, or zero address on failure.\r\n     */\r\n    function createSender(\r\n        bytes calldata initCode\r\n    ) external returns (address sender) {\r\n        address factory = address(bytes20(initCode[0:20]));\r\n        bytes memory initCallData = initCode[20:];\r\n        bool success;\r\n        /* solhint-disable no-inline-assembly */\r\n        assembly (\"memory-safe\") {\r\n            success := call(\r\n                gas(),\r\n                factory,\r\n                0,\r\n                add(initCallData, 0x20),\r\n                mload(initCallData),\r\n                0,\r\n                32\r\n            )\r\n            sender := mload(0)\r\n        }\r\n        if (!success) {\r\n            sender = address(0);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/StakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity ^0.8.23;\r\n\r\nimport \"../interfaces/IStakeManager.sol\";\r\n\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable not-rely-on-time */\r\n\r\n/**\r\n * Manage deposits and stakes.\r\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\r\n * Stake is value locked for at least \"unstakeDelay\" by a paymaster.\r\n */\r\nabstract contract StakeManager is IStakeManager {\r\n    /// maps paymaster to their deposits and stakes\r\n    mapping(address => DepositInfo) public deposits;\r\n\r\n    /// @inheritdoc IStakeManager\r\n    function getDepositInfo(\r\n        address account\r\n    ) public view returns (DepositInfo memory info) {\r\n        return deposits[account];\r\n    }\r\n\r\n    /**\r\n     * Internal method to return just the stake info.\r\n     * @param addr - The account to query.\r\n     */\r\n    function _getStakeInfo(\r\n        address addr\r\n    ) internal view returns (StakeInfo memory info) {\r\n        DepositInfo storage depositInfo = deposits[addr];\r\n        info.stake = depositInfo.stake;\r\n        info.unstakeDelaySec = depositInfo.unstakeDelaySec;\r\n    }\r\n\r\n    /// @inheritdoc IStakeManager\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return deposits[account].deposit;\r\n    }\r\n\r\n    receive() external payable {\r\n        depositTo(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * Increments an account's deposit.\r\n     * @param account - The account to increment.\r\n     * @param amount  - The amount to increment by.\r\n     * @return the updated deposit of this account\r\n     */\r\n    function _incrementDeposit(address account, uint256 amount) internal returns (uint256) {\r\n        DepositInfo storage info = deposits[account];\r\n        uint256 newAmount = info.deposit + amount;\r\n        info.deposit = newAmount;\r\n        return newAmount;\r\n    }\r\n\r\n    /**\r\n     * Add to the deposit of the given account.\r\n     * @param account - The account to add to.\r\n     */\r\n    function depositTo(address account) public virtual payable {\r\n        uint256 newDeposit = _incrementDeposit(account, msg.value);\r\n        emit Deposited(account, newDeposit);\r\n    }\r\n\r\n    /**\r\n     * Add to the account's stake - amount and delay\r\n     * any pending unstake is first cancelled.\r\n     * @param unstakeDelaySec The new lock duration before the deposit can be withdrawn.\r\n     */\r\n    function addStake(uint32 unstakeDelaySec) public payable {\r\n        DepositInfo storage info = deposits[msg.sender];\r\n        require(unstakeDelaySec > 0, \"must specify unstake delay\");\r\n        require(\r\n            unstakeDelaySec >= info.unstakeDelaySec,\r\n            \"cannot decrease unstake time\"\r\n        );\r\n        uint256 stake = info.stake + msg.value;\r\n        require(stake > 0, \"no stake specified\");\r\n        require(stake <= type(uint112).max, \"stake overflow\");\r\n        deposits[msg.sender] = DepositInfo(\r\n            info.deposit,\r\n            true,\r\n            uint112(stake),\r\n            unstakeDelaySec,\r\n            0\r\n        );\r\n        emit StakeLocked(msg.sender, stake, unstakeDelaySec);\r\n    }\r\n\r\n    /**\r\n     * Attempt to unlock the stake.\r\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\r\n     */\r\n    function unlockStake() external {\r\n        DepositInfo storage info = deposits[msg.sender];\r\n        require(info.unstakeDelaySec != 0, \"not staked\");\r\n        require(info.staked, \"already unstaking\");\r\n        uint48 withdrawTime = uint48(block.timestamp) + info.unstakeDelaySec;\r\n        info.withdrawTime = withdrawTime;\r\n        info.staked = false;\r\n        emit StakeUnlocked(msg.sender, withdrawTime);\r\n    }\r\n\r\n    /**\r\n     * Withdraw from the (unlocked) stake.\r\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\r\n     * @param withdrawAddress - The address to send withdrawn value.\r\n     */\r\n    function withdrawStake(address payable withdrawAddress) external {\r\n        DepositInfo storage info = deposits[msg.sender];\r\n        uint256 stake = info.stake;\r\n        require(stake > 0, \"No stake to withdraw\");\r\n        require(info.withdrawTime > 0, \"must call unlockStake() first\");\r\n        require(\r\n            info.withdrawTime <= block.timestamp,\r\n            \"Stake withdrawal is not due\"\r\n        );\r\n        info.unstakeDelaySec = 0;\r\n        info.withdrawTime = 0;\r\n        info.stake = 0;\r\n        emit StakeWithdrawn(msg.sender, withdrawAddress, stake);\r\n        (bool success,) = withdrawAddress.call{value: stake}(\"\");\r\n        require(success, \"failed to withdraw stake\");\r\n    }\r\n\r\n    /**\r\n     * Withdraw from the deposit.\r\n     * @param withdrawAddress - The address to send withdrawn value.\r\n     * @param withdrawAmount  - The amount to withdraw.\r\n     */\r\n    function withdrawTo(\r\n        address payable withdrawAddress,\r\n        uint256 withdrawAmount\r\n    ) external {\r\n        DepositInfo storage info = deposits[msg.sender];\r\n        require(withdrawAmount <= info.deposit, \"Withdraw amount too large\");\r\n        info.deposit = info.deposit - withdrawAmount;\r\n        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);\r\n        (bool success,) = withdrawAddress.call{value: withdrawAmount}(\"\");\r\n        require(success, \"failed to withdraw\");\r\n    }\r\n}\r\n"
    },
    "contracts/core/UserOperationLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.23;\r\n\r\n/* solhint-disable no-inline-assembly */\r\n\r\nimport \"../interfaces/PackedUserOperation.sol\";\r\nimport {calldataKeccak, min} from \"./Helpers.sol\";\r\n\r\n/**\r\n * Utility functions helpful when working with UserOperation structs.\r\n */\r\nlibrary UserOperationLib {\r\n\r\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\r\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\r\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\r\n    /**\r\n     * Get sender from user operation data.\r\n     * @param userOp - The user operation data.\r\n     */\r\n    function getSender(\r\n        PackedUserOperation calldata userOp\r\n    ) internal pure returns (address) {\r\n        address data;\r\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\r\n        assembly {\r\n            data := calldataload(userOp)\r\n        }\r\n        return address(uint160(data));\r\n    }\r\n\r\n    /**\r\n     * Relayer/block builder might submit the TX with higher priorityFee,\r\n     * but the user should not pay above what he signed for.\r\n     * @param userOp - The user operation data.\r\n     */\r\n    function gasPrice(\r\n        PackedUserOperation calldata userOp\r\n    ) internal view returns (uint256) {\r\n        unchecked {\r\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\r\n            if (maxFeePerGas == maxPriorityFeePerGas) {\r\n                //legacy mode (for networks that don't support basefee opcode)\r\n                return maxFeePerGas;\r\n            }\r\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pack the user operation data into bytes for hashing.\r\n     * @param userOp - The user operation data.\r\n     */\r\n    function encode(\r\n        PackedUserOperation calldata userOp\r\n    ) internal pure returns (bytes memory ret) {\r\n        address sender = getSender(userOp);\r\n        uint256 nonce = userOp.nonce;\r\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\r\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\r\n        bytes32 accountGasLimits = userOp.accountGasLimits;\r\n        uint256 preVerificationGas = userOp.preVerificationGas;\r\n        bytes32 gasFees = userOp.gasFees;\r\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\r\n\r\n        return abi.encode(\r\n            sender, nonce,\r\n            hashInitCode, hashCallData,\r\n            accountGasLimits, preVerificationGas, gasFees,\r\n            hashPaymasterAndData\r\n        );\r\n    }\r\n\r\n    function unpackUints(\r\n        bytes32 packed\r\n    ) internal pure returns (uint256 high128, uint256 low128) {\r\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\r\n    }\r\n\r\n    //unpack just the high 128-bits from a packed value\r\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\r\n        return uint256(packed) >> 128;\r\n    }\r\n\r\n    // unpack just the low 128-bits from a packed value\r\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\r\n        return uint128(uint256(packed));\r\n    }\r\n\r\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\r\n    internal pure returns (uint256) {\r\n        return unpackHigh128(userOp.gasFees);\r\n    }\r\n\r\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\r\n    internal pure returns (uint256) {\r\n        return unpackLow128(userOp.gasFees);\r\n    }\r\n\r\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\r\n    internal pure returns (uint256) {\r\n        return unpackHigh128(userOp.accountGasLimits);\r\n    }\r\n\r\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\r\n    internal pure returns (uint256) {\r\n        return unpackLow128(userOp.accountGasLimits);\r\n    }\r\n\r\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\r\n    internal pure returns (uint256) {\r\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\r\n    }\r\n\r\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\r\n    internal pure returns (uint256) {\r\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\r\n    }\r\n\r\n    function unpackPaymasterStaticFields(\r\n        bytes calldata paymasterAndData\r\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\r\n        return (\r\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\r\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\r\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Hash the user operation data.\r\n     * @param userOp - The user operation data.\r\n     */\r\n    function hash(\r\n        PackedUserOperation calldata userOp\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(encode(userOp));\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.5;\r\n\r\nimport \"./PackedUserOperation.sol\";\r\n\r\ninterface IAccount {\r\n    /**\r\n     * Validate user's signature and nonce\r\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\r\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\r\n     * This allows making a \"simulation call\" without a valid signature\r\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\r\n     *\r\n     * @dev Must validate caller is the entryPoint.\r\n     *      Must validate the signature and nonce\r\n     * @param userOp              - The operation that is about to be executed.\r\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\r\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\r\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\r\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\r\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\r\n     *                              In case there is a paymaster in the request (or the current deposit is high\r\n     *                              enough), this value will be zero.\r\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\r\n     *                              `_unpackValidationData` to encode and decode.\r\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\r\n     *                                 otherwise, an address of an \"authorizer\" contract.\r\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\r\n     *                              <6-byte> validAfter - First timestamp this operation is valid\r\n     *                                                    If an account doesn't use time-range, it is enough to\r\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\r\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\r\n     */\r\n    function validateUserOp(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash,\r\n        uint256 missingAccountFunds\r\n    ) external returns (uint256 validationData);\r\n}\r\n"
    },
    "contracts/interfaces/IAccountExecute.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.5;\r\n\r\nimport \"./PackedUserOperation.sol\";\r\n\r\ninterface IAccountExecute {\r\n    /**\r\n     * Account may implement this execute method.\r\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the full UserOp (and hash)\r\n     * to the account.\r\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp fields)\r\n     *\r\n     * @param userOp              - The operation that was just validated.\r\n     * @param userOpHash          - Hash of the user's request data.\r\n     */\r\n    function executeUserOp(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.5;\r\n\r\nimport \"./PackedUserOperation.sol\";\r\n\r\n/**\r\n * Aggregated Signatures validator.\r\n */\r\ninterface IAggregator {\r\n    /**\r\n     * Validate aggregated signature.\r\n     * Revert if the aggregated signature does not match the given list of operations.\r\n     * @param userOps   - Array of UserOperations to validate the signature for.\r\n     * @param signature - The aggregated signature.\r\n     */\r\n    function validateSignatures(\r\n        PackedUserOperation[] calldata userOps,\r\n        bytes calldata signature\r\n    ) external view;\r\n\r\n    /**\r\n     * Validate signature of a single userOp.\r\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\r\n     * the aggregator this account uses.\r\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\r\n     * @param userOp        - The userOperation received from the user.\r\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\r\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\r\n     */\r\n    function validateUserOpSignature(\r\n        PackedUserOperation calldata userOp\r\n    ) external view returns (bytes memory sigForUserOp);\r\n\r\n    /**\r\n     * Aggregate multiple signatures into a single value.\r\n     * This method is called off-chain to calculate the signature to pass with handleOps()\r\n     * bundler MAY use optimized custom code perform this aggregation.\r\n     * @param userOps              - Array of UserOperations to collect the signatures from.\r\n     * @return aggregatedSignature - The aggregated signature.\r\n     */\r\n    function aggregateSignatures(\r\n        PackedUserOperation[] calldata userOps\r\n    ) external view returns (bytes memory aggregatedSignature);\r\n}\r\n"
    },
    "contracts/interfaces/IEntryPoint.sol": {
      "content": "/**\r\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\r\n ** Only one instance required on each chain.\r\n **/\r\n// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.5;\r\n\r\n/* solhint-disable avoid-low-level-calls */\r\n/* solhint-disable no-inline-assembly */\r\n/* solhint-disable reason-string */\r\n\r\nimport \"./PackedUserOperation.sol\";\r\nimport \"./IStakeManager.sol\";\r\nimport \"./IAggregator.sol\";\r\nimport \"./INonceManager.sol\";\r\n\r\ninterface IEntryPoint is IStakeManager, INonceManager {\r\n    /***\r\n     * An event emitted after each successful request.\r\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\r\n     * @param sender        - The account that generates this request.\r\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\r\n     * @param nonce         - The nonce value from the request.\r\n     * @param success       - True if the sender transaction succeeded, false if reverted.\r\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\r\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\r\n     *                        validation and execution).\r\n     */\r\n    event UserOperationEvent(\r\n        bytes32 indexed userOpHash,\r\n        address indexed sender,\r\n        address indexed paymaster,\r\n        uint256 nonce,\r\n        bool success,\r\n        uint256 actualGasCost,\r\n        uint256 actualGasUsed\r\n    );\r\n\r\n    /**\r\n     * Account \"sender\" was deployed.\r\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\r\n     * @param sender     - The account that is deployed\r\n     * @param factory    - The factory used to deploy this account (in the initCode)\r\n     * @param paymaster  - The paymaster used by this UserOp\r\n     */\r\n    event AccountDeployed(\r\n        bytes32 indexed userOpHash,\r\n        address indexed sender,\r\n        address factory,\r\n        address paymaster\r\n    );\r\n\r\n    /**\r\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\r\n     * @param userOpHash   - The request unique identifier.\r\n     * @param sender       - The sender of this request.\r\n     * @param nonce        - The nonce used in the request.\r\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\r\n     */\r\n    event UserOperationRevertReason(\r\n        bytes32 indexed userOpHash,\r\n        address indexed sender,\r\n        uint256 nonce,\r\n        bytes revertReason\r\n    );\r\n\r\n    /**\r\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\r\n     * @param userOpHash   - The request unique identifier.\r\n     * @param sender       - The sender of this request.\r\n     * @param nonce        - The nonce used in the request.\r\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\r\n     */\r\n    event PostOpRevertReason(\r\n        bytes32 indexed userOpHash,\r\n        address indexed sender,\r\n        uint256 nonce,\r\n        bytes revertReason\r\n    );\r\n\r\n    /**\r\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\r\n     * @param userOpHash   - The request unique identifier.\r\n     * @param sender       - The sender of this request.\r\n     * @param nonce        - The nonce used in the request.\r\n     */\r\n    event UserOperationPrefundTooLow(\r\n        bytes32 indexed userOpHash,\r\n        address indexed sender,\r\n        uint256 nonce\r\n    );\r\n\r\n    /**\r\n     * An event emitted by handleOps(), before starting the execution loop.\r\n     * Any event emitted before this event, is part of the validation.\r\n     */\r\n    event BeforeExecution();\r\n\r\n    /**\r\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\r\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\r\n     */\r\n    event SignatureAggregatorChanged(address indexed aggregator);\r\n\r\n    /**\r\n     * A custom revert error of handleOps, to identify the offending op.\r\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\r\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\r\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\r\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\r\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\r\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\r\n     *                  so a failure can be attributed to the correct entity.\r\n     */\r\n    error FailedOp(uint256 opIndex, string reason);\r\n\r\n    /**\r\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\r\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\r\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\r\n     * @param inner   - data from inner cought revert reason\r\n     * @dev note that inner is truncated to 2048 bytes\r\n     */\r\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\r\n\r\n    error PostOpReverted(bytes returnData);\r\n\r\n    /**\r\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\r\n     * @param aggregator The aggregator that failed to verify the signature\r\n     */\r\n    error SignatureValidationFailed(address aggregator);\r\n\r\n    // Return value of getSenderAddress.\r\n    error SenderAddressResult(address sender);\r\n\r\n    // UserOps handled, per aggregator.\r\n    struct UserOpsPerAggregator {\r\n        PackedUserOperation[] userOps;\r\n        // Aggregator address\r\n        IAggregator aggregator;\r\n        // Aggregated signature\r\n        bytes signature;\r\n    }\r\n\r\n    /**\r\n     * Execute a batch of UserOperations.\r\n     * No signature aggregator is used.\r\n     * If any account requires an aggregator (that is, it returned an aggregator when\r\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\r\n     * @param ops         - The operations to execute.\r\n     * @param beneficiary - The address to receive the fees.\r\n     */\r\n    function handleOps(\r\n        PackedUserOperation[] calldata ops,\r\n        address payable beneficiary\r\n    ) external;\r\n\r\n    /**\r\n     * Execute a batch of UserOperation with Aggregators\r\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\r\n     * @param beneficiary      - The address to receive the fees.\r\n     */\r\n    function handleAggregatedOps(\r\n        UserOpsPerAggregator[] calldata opsPerAggregator,\r\n        address payable beneficiary\r\n    ) external;\r\n\r\n    /**\r\n     * Generate a request Id - unique identifier for this request.\r\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\r\n     * @param userOp - The user operation to generate the request ID for.\r\n     * @return hash the hash of this UserOperation\r\n     */\r\n    function getUserOpHash(\r\n        PackedUserOperation calldata userOp\r\n    ) external view returns (bytes32);\r\n\r\n    /**\r\n     * Gas and return values during simulation.\r\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\r\n     * @param prefund          - The required prefund for this operation\r\n     * @param accountValidationData   - returned validationData from account.\r\n     * @param paymasterValidationData - return validationData from paymaster.\r\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\r\n     */\r\n    struct ReturnInfo {\r\n        uint256 preOpGas;\r\n        uint256 prefund;\r\n        uint256 accountValidationData;\r\n        uint256 paymasterValidationData;\r\n        bytes paymasterContext;\r\n    }\r\n\r\n    /**\r\n     * Returned aggregated signature info:\r\n     * The aggregator returned by the account, and its current stake.\r\n     */\r\n    struct AggregatorStakeInfo {\r\n        address aggregator;\r\n        StakeInfo stakeInfo;\r\n    }\r\n\r\n    /**\r\n     * Get counterfactual sender address.\r\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\r\n     * This method always revert, and returns the address in SenderAddressResult error\r\n     * @param initCode - The constructor code to be passed into the UserOperation.\r\n     */\r\n    function getSenderAddress(bytes memory initCode) external;\r\n\r\n    error DelegateAndRevert(bool success, bytes ret);\r\n\r\n    /**\r\n     * Helper method for dry-run testing.\r\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\r\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\r\n     *  actual EntryPoint code is less convenient.\r\n     * @param target a target contract to make a delegatecall from entrypoint\r\n     * @param data data to pass to target in a delegatecall\r\n     */\r\n    function delegateAndRevert(address target, bytes calldata data) external;\r\n}\r\n"
    },
    "contracts/interfaces/IEntryPointSimulations.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.5;\r\n\r\nimport \"./PackedUserOperation.sol\";\r\nimport \"./IEntryPoint.sol\";\r\n\r\ninterface IEntryPointSimulations is IEntryPoint {\r\n    // Return value of simulateHandleOp.\r\n    struct ExecutionResult {\r\n        uint256 preOpGas;\r\n        uint256 paid;\r\n        uint256 accountValidationData;\r\n        uint256 paymasterValidationData;\r\n        bool targetSuccess;\r\n        bytes targetResult;\r\n    }\r\n\r\n    /**\r\n     * Successful result from simulateValidation.\r\n     * If the account returns a signature aggregator the \"aggregatorInfo\" struct is filled in as well.\r\n     * @param returnInfo     Gas and time-range returned values\r\n     * @param senderInfo     Stake information about the sender\r\n     * @param factoryInfo    Stake information about the factory (if any)\r\n     * @param paymasterInfo  Stake information about the paymaster (if any)\r\n     * @param aggregatorInfo Signature aggregation info (if the account requires signature aggregator)\r\n     *                       Bundler MUST use it to verify the signature, or reject the UserOperation.\r\n     */\r\n    struct ValidationResult {\r\n        ReturnInfo returnInfo;\r\n        StakeInfo senderInfo;\r\n        StakeInfo factoryInfo;\r\n        StakeInfo paymasterInfo;\r\n        AggregatorStakeInfo aggregatorInfo;\r\n    }\r\n\r\n    /**\r\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\r\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage\r\n     *      outside the account's data.\r\n     * @param userOp - The user operation to validate.\r\n     * @return the validation result structure\r\n     */\r\n    function simulateValidation(\r\n        PackedUserOperation calldata userOp\r\n    )\r\n    external\r\n    returns (\r\n        ValidationResult memory\r\n    );\r\n\r\n    /**\r\n     * Simulate full execution of a UserOperation (including both validation and target execution)\r\n     * It performs full validation of the UserOperation, but ignores signature error.\r\n     * An optional target address is called after the userop succeeds,\r\n     * and its value is returned (before the entire call is reverted).\r\n     * Note that in order to collect the the success/failure of the target call, it must be executed\r\n     * with trace enabled to track the emitted events.\r\n     * @param op The UserOperation to simulate.\r\n     * @param target         - If nonzero, a target address to call after userop simulation. If called,\r\n     *                         the targetSuccess and targetResult are set to the return from that call.\r\n     * @param targetCallData - CallData to pass to target address.\r\n     * @return the execution result structure\r\n     */\r\n    function simulateHandleOp(\r\n        PackedUserOperation calldata op,\r\n        address target,\r\n        bytes calldata targetCallData\r\n    )\r\n    external\r\n    returns (\r\n        ExecutionResult memory\r\n    );\r\n}\r\n"
    },
    "contracts/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.5;\r\n\r\ninterface INonceManager {\r\n\r\n    /**\r\n     * Return the next nonce for this sender.\r\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\r\n     * But UserOp with different keys can come with arbitrary order.\r\n     *\r\n     * @param sender the account address\r\n     * @param key the high 192 bit of the nonce\r\n     * @return nonce a full nonce to pass for next UserOp with this sender.\r\n     */\r\n    function getNonce(address sender, uint192 key)\r\n    external view returns (uint256 nonce);\r\n\r\n    /**\r\n     * Manually increment the nonce of the sender.\r\n     * This method is exposed just for completeness..\r\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\r\n     * as the EntryPoint will update the nonce regardless.\r\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\r\n     * UserOperations will not pay extra for the first transaction with a given key.\r\n     */\r\n    function incrementNonce(uint192 key) external;\r\n}\r\n"
    },
    "contracts/interfaces/IPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.5;\r\n\r\nimport \"./PackedUserOperation.sol\";\r\n\r\n/**\r\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\r\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\r\n */\r\ninterface IPaymaster {\r\n    enum PostOpMode {\r\n        // User op succeeded.\r\n        opSucceeded,\r\n        // User op reverted. Still has to pay for gas.\r\n        opReverted,\r\n        // Only used internally in the EntryPoint (cleanup after postOp reverts). Never calling paymaster with this value\r\n        postOpReverted\r\n    }\r\n\r\n    /**\r\n     * Payment validation: check if paymaster agrees to pay.\r\n     * Must verify sender is the entryPoint.\r\n     * Revert to reject this request.\r\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\r\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\r\n     * @param userOp          - The user operation.\r\n     * @param userOpHash      - Hash of the user's request data.\r\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\r\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\r\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\r\n     *                          value of validateUserOperation.\r\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\r\n     *                                                    other values are invalid for paymaster.\r\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\r\n     *                          <6-byte> validAfter - first timestamp this operation is valid\r\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\r\n     */\r\n    function validatePaymasterUserOp(\r\n        PackedUserOperation calldata userOp,\r\n        bytes32 userOpHash,\r\n        uint256 maxCost\r\n    ) external returns (bytes memory context, uint256 validationData);\r\n\r\n    /**\r\n     * Post-operation handler.\r\n     * Must verify sender is the entryPoint.\r\n     * @param mode          - Enum with the following options:\r\n     *                        opSucceeded - User operation succeeded.\r\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\r\n     *                        postOpReverted - never passed in a call to postOp().\r\n     * @param context       - The context value returned by validatePaymasterUserOp\r\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\r\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\r\n     *                        and maxPriorityFee (and basefee)\r\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\r\n     */\r\n    function postOp(\r\n        PostOpMode mode,\r\n        bytes calldata context,\r\n        uint256 actualGasCost,\r\n        uint256 actualUserOpFeePerGas\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity >=0.7.5;\r\n\r\n/**\r\n * Manage deposits and stakes.\r\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\r\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\r\n */\r\ninterface IStakeManager {\r\n    event Deposited(address indexed account, uint256 totalDeposit);\r\n\r\n    event Withdrawn(\r\n        address indexed account,\r\n        address withdrawAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    // Emitted when stake or unstake delay are modified.\r\n    event StakeLocked(\r\n        address indexed account,\r\n        uint256 totalStaked,\r\n        uint256 unstakeDelaySec\r\n    );\r\n\r\n    // Emitted once a stake is scheduled for withdrawal.\r\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\r\n\r\n    event StakeWithdrawn(\r\n        address indexed account,\r\n        address withdrawAddress,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @param deposit         - The entity's deposit.\r\n     * @param staked          - True if this entity is staked.\r\n     * @param stake           - Actual amount of ether staked for this entity.\r\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\r\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\r\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\r\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\r\n     *      - 112 bit allows for 10^15 eth\r\n     *      - 48 bit for full timestamp\r\n     *      - 32 bit allows 150 years for unstake delay\r\n     */\r\n    struct DepositInfo {\r\n        uint256 deposit;\r\n        bool staked;\r\n        uint112 stake;\r\n        uint32 unstakeDelaySec;\r\n        uint48 withdrawTime;\r\n    }\r\n\r\n    // API struct used by getStakeInfo and simulateValidation.\r\n    struct StakeInfo {\r\n        uint256 stake;\r\n        uint256 unstakeDelaySec;\r\n    }\r\n\r\n    /**\r\n     * Get deposit info.\r\n     * @param account - The account to query.\r\n     * @return info   - Full deposit information of given account.\r\n     */\r\n    function getDepositInfo(\r\n        address account\r\n    ) external view returns (DepositInfo memory info);\r\n\r\n    /**\r\n     * Get account balance.\r\n     * @param account - The account to query.\r\n     * @return        - The deposit (for gas payment) of the account.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * Add to the deposit of the given account.\r\n     * @param account - The account to add to.\r\n     */\r\n    function depositTo(address account) external payable;\r\n\r\n    /**\r\n     * Add to the account's stake - amount and delay\r\n     * any pending unstake is first cancelled.\r\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\r\n     */\r\n    function addStake(uint32 _unstakeDelaySec) external payable;\r\n\r\n    /**\r\n     * Attempt to unlock the stake.\r\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\r\n     */\r\n    function unlockStake() external;\r\n\r\n    /**\r\n     * Withdraw from the (unlocked) stake.\r\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\r\n     * @param withdrawAddress - The address to send withdrawn value.\r\n     */\r\n    function withdrawStake(address payable withdrawAddress) external;\r\n\r\n    /**\r\n     * Withdraw from the deposit.\r\n     * @param withdrawAddress - The address to send withdrawn value.\r\n     * @param withdrawAmount  - The amount to withdraw.\r\n     */\r\n    function withdrawTo(\r\n        address payable withdrawAddress,\r\n        uint256 withdrawAmount\r\n    ) external;\r\n}\r\n"
    },
    "contracts/interfaces/PackedUserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.5;\r\n\r\n/**\r\n * User Operation struct\r\n * @param sender                - The sender account of this request.\r\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\r\n * @param initCode              - If set, the account contract will be created by this constructor/\r\n * @param callData              - The method call to execute on this account.\r\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\r\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\r\n *                                Covers batch overhead.\r\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\r\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\r\n *                                The paymaster will pay for the transaction instead of the sender.\r\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\r\n */\r\nstruct PackedUserOperation {\r\n    address sender;\r\n    uint256 nonce;\r\n    bytes initCode;\r\n    bytes callData;\r\n    bytes32 accountGasLimits;\r\n    uint256 preVerificationGas;\r\n    bytes32 gasFees;\r\n    bytes paymasterAndData;\r\n    bytes signature;\r\n}\r\n"
    },
    "contracts/utils/Exec.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\r\npragma solidity ^0.8.23;\r\n\r\n// solhint-disable no-inline-assembly\r\n\r\n/**\r\n * Utility functions helpful when making different kinds of contract calls in Solidity.\r\n */\r\nlibrary Exec {\r\n\r\n    function call(\r\n        address to,\r\n        uint256 value,\r\n        bytes memory data,\r\n        uint256 txGas\r\n    ) internal returns (bool success) {\r\n        assembly (\"memory-safe\") {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function staticcall(\r\n        address to,\r\n        bytes memory data,\r\n        uint256 txGas\r\n    ) internal view returns (bool success) {\r\n        assembly (\"memory-safe\") {\r\n            success := staticcall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function delegateCall(\r\n        address to,\r\n        bytes memory data,\r\n        uint256 txGas\r\n    ) internal returns (bool success) {\r\n        assembly (\"memory-safe\") {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    // get returned data from last call or calldelegate\r\n    function getReturnData(uint256 maxLen) internal pure returns (bytes memory returnData) {\r\n        assembly (\"memory-safe\") {\r\n            let len := returndatasize()\r\n            if gt(len, maxLen) {\r\n                len := maxLen\r\n            }\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, add(len, 0x20)))\r\n            mstore(ptr, len)\r\n            returndatacopy(add(ptr, 0x20), 0, len)\r\n            returnData := ptr\r\n        }\r\n    }\r\n\r\n    // revert with explicit byte array (probably reverted info from call)\r\n    function revertWithData(bytes memory returnData) internal pure {\r\n        assembly (\"memory-safe\") {\r\n            revert(add(returnData, 32), mload(returnData))\r\n        }\r\n    }\r\n\r\n    function callAndRevert(address to, bytes memory data, uint256 maxLen) internal {\r\n        bool success = call(to,0,data,gasleft());\r\n        if (!success) {\r\n            revertWithData(getReturnData(maxLen));\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 128
    },
    "viaIR": false,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}